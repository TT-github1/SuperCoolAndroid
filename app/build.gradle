/**
 * 声明是Android程序，
 * com.android.application 表示这是一个应用程序模块,可以直接运行，打包得到的是.apk文件
 * com.android.library 标识这是一个库模块,只能作为代码库依附于别的应用程序模块来运行，打包得到的是.aar文件
 * 而这区别：前者可以直接运行，后着是依附别的应用程序运行
 * 这里不止可以写这一行，还有很多，例如apply plugin: 'kotlin-android'
 */
apply plugin: 'com.android.application'

android {
    compileSdkVersion 30          //设置编译时用的Android版本
    buildToolsVersion "30.0.0"    //设置编译时使用的构建工具的版本

    defaultConfig {
        applicationId "com.tthappy.supercoolandroid"    //项目的包名
        minSdkVersion 24                                //项目最低兼容的版本
        targetSdkVersion 30                             //项目的目标版本
        versionCode 1                                   //版本号,一般每次打包上线时该值只能增加，打包后看不见。
        versionName "1.0"                               //版本名称,展示在应用市场上。

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"    //表明要使用AndroidJUnitRunner进行单元测试
        android.defaultConfig.vectorDrawables.useSupportLibrary = true

        dataBinding {
            enabled true
        }

        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [ AROUTER_MODULE_NAME : project.getName() ]
            }
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }


        applicationVariants.all { variant ->
            variant.outputs.all {
                outputFileName = "SuperCoolAndroid.apk"
            }
        }

    }
    /**
     *     buildTypes {// 生产/测试环境配置
     *         release {// 生产环境
     *             buildConfigField("boolean", "LOG_DEBUG", "false")//配置Log日志
     *             buildConfigField("String", "URL_PERFIX", "\"https://release.cn/\"")// 配置URL前缀
     *             minifyEnabled false//是否对代码进行混淆
     *             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//指定混淆的规则文件
     *             signingConfig signingConfigs.release//设置签名信息
     *             pseudoLocalesEnabled false//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多
     *             zipAlignEnabled true//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率
     *             applicationIdSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多
     *             versionNameSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多
     *}
     *         debug {// 测试环境
     *             buildConfigField("boolean", "LOG_DEBUG", "true")//配置Log日志
     *             buildConfigField("String", "URL_PERFIX", "\"https://test.com/\"")// 配置URL前缀
     *             minifyEnabled false//是否对代码进行混淆
     *             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//指定混淆的规则文件
     *             signingConfig signingConfigs.debug//设置签名信息
     *             debuggable false//是否支持断点调试
     *             jniDebuggable false//是否可以调试NDK代码
     *             renderscriptDebuggable false//是否开启渲染脚本就是一些c写的渲染方法
     *             zipAlignEnabled true//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率
     *             pseudoLocalesEnabled false//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多
     *             applicationIdSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多
     *             versionNameSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多
     *         }
     *     }
     *
     *     minifyEnabled：表明是否对代码进行混淆，true表示对代码进行混淆，false表示对代码不进行混淆，默认的是false。
     *     proguardFiles：指定混淆的规则文件，这里指定了proguard-android.txt文件和proguard-rules.pro文件两个文件，proguard-android.txt文件为默认的混淆文件，里面定义了一些通用的混淆规则。proguard-rules.pro文件位于当前项目的根目录下，可以在该文件中定义一些项目特有的混淆规则。
     *     buildConfigField：用于解决Beta版本服务和Release版本服务地址不同或者一些Log打印需求控制的。例如：配置buildConfigField("boolean", "LOG_DEBUG", "true")，这个方法接收三个非空的参数，第一个：确定值的类型，第二个：指定key的名字，第三个：传值，调用的时候BuildConfig.LOG_DEBUG即可调用。
     *     debuggable：表示是否支持断点调试，release默认为false，debug默认为true。
     *     jniDebuggable：表示是否可以调试NDK代码，使用lldb进行c和c++代码调试，release默认为false
     *     signingConfig：设置签名信息，通过signingConfigs.release或者signingConfigs.debug，配置相应的签名，但是添加此配置前必须先添加signingConfigs闭包，添加相应的签名信息。
     *     renderscriptDebuggable：表示是否开启渲染脚本就是一些c写的渲染方法，默认为false。
     *     renderscriptOptimLevel：表示渲染等级，默认是3。
     *     pseudoLocalesEnabled：是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多。
     *     applicationIdSuffix：和defaultConfig中配置是一的，这里是在applicationId 中添加了一个后缀，一般使用的不多。
     *     versionNameSuffix：表示添加版本名称的后缀，一般使用的不多。
     *     zipAlignEnabled：表示是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率，release和debug默认都为true。
     */



    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8    //编辑的时候用的是JDK1.8（只能用JDK1.8的特性）
        targetCompatibility JavaVersion.VERSION_1_8    //生成的是1.8的.class文件
    }

    /**
     *     signingConfigs {// 自动化打包配置
     *         release {// 线上环境
     *             keyAlias 'test'
     *             keyPassword '123456'
     *             storeFile file('test.keystore')
     *             storePassword '123456'
     *}
     *         debug {// 开发环境
     *             keyAlias 'test'
     *             keyPassword '123456'
     *             storeFile file('test.keystore')
     *             storePassword '123456'
     *         }
     *     }
     */



    sourceSets {//目录指向配置
        main {
            jniLibs.srcDirs = ['libs']//指定lib库目录
        }
    }
    /**
     *     配置 jniLibs.srcDirs = ['libs']，可以在Android studio的Android视图下生成jniLibs文件夹，
     *     可以方便我们存放jar包和库文件，
     *     其中Android视图下的jniLibs和project视图下的libs指向同一文件夹（app→libs）
     */


    /**
     *     packagingOptions{*         //pickFirsts做用是 当有重复文件时 打包会报错 这样配置会使用第一个匹配的文件打包进入apk
     *         // 表示当apk中有重复的META-INF目录下有重复的LICENSE文件时  只用第一个 这样打包就不会报错
     *         pickFirsts = ['META-INF/LICENSE']
     *
     *         //merges何必 当出现重复文件时 合并重复的文件 然后打包入apk
     *         //这个是有默认值得 merges = [] 这样会把默默认值去掉  所以我们用下面这种方式 在默认值后添加
     *         merge 'META-INF/LICENSE'
     *
     *         //这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。
     *         exclude 'META-INF/services/javax.annotation.processing.Processor'
     *     }
     *
     *     当项目中依赖的第三方库越来越多时，
     *     有可能会出现两个依赖库中存在同一个（名称）文件。
     *     如果这样，Gradle在打包时就会提示错误（警告）。
     *     那么就可以根据提示，然后使用以下方法将重复的文件剔除，
     *     比较常用的是通过exclude去除重复的文件，例如：
     */




    /**
     *    productFlavors {*
     *        wandoujia {*             //豌豆荚渠道包配置
     *             manifestPlaceholders = [UMENG_CHANNEL_VALUE: "wandoujia"]
     *             //manifestPlaceholders的使用在后续章节（AndroidManifest里的占位符）中介绍
     *        }
     *        xiaomi {
     *             manifestPlaceholders = [UMENG_CHANNEL_VALUE: "xiaomi"]
     *             applicationId "com.wiky.gradle.xiaomi" //配置包名
     *
     *         }
     *         _360 {
     *             manifestPlaceholders = [UMENG_CHANN ]
     *         }
     *         //...
     *     }
     *
     *     这个配置是经常会使用到的，通常在适配多个渠道的时候，
     *     需要为特定的渠道做部分特殊的处理，比如设置不同的包名、
     *     应用名等。场景：当我们使用友盟统计时，
     *     通常需要设置一个渠道ID，
     *     那么我们就可以利用productFlavors来生成对应渠道信息的包
     *
     *     配置完之后，在命令行窗口中（Terminal）中输入gradlew assembleRelease（windows）即可开始打包，
     *     在Mac系统中对应指令应该是./gradlew assembleRelease。当然，如果想要debug版本的包，
     *     将指令中assembleRelease改为assembleDebug即可。最后生成的包还是在app/build/outputs/apk中，
     *     默认命名格式如app-wandoujia-release-unsigned.apk，
     *     在module的Build Variants中可以选择相应的渠道。
     */

    /**
     * 补充说明：
     *      渠道包指的是在各大应用市场，发布的apk包的清单文件中，
     *      某个baimeta-data标签下，配置的value不一样，
     *      这个标签的作用就是用来区分是哪个市场的，
     *      比如你发布到360.这个值就是你就可以配置成360，
     *      豌豆荚就可以配置成wandoujia，那么这么配置的作用是干嘛的？很简单，
     *      就是用来做统计的，比如我们项目中用的是友盟统计，
     *      它可以统计用户从哪个平台下载了你们的app，
     *      从而更好的掌握用户的操作习惯。所以，如果app没有统计功能的需求，
     *      你只需要打一个同样的包，直接发布到各个平台即可，根本不用关心什么渠道。
     */





    //程序在编译的时候会检查lint，有任何错误提示会停止build，我们可以关闭这个开关
    lintOptions {
        abortOnError false //即使报错也不会停止打包
        checkReleaseBuilds false  //打包release版本的时候进行检测
    }
    /**
     *     Lint 是Android Studio 提供的 代码扫描分析工具，它可以帮助我们发现代码结构/质量问题，
     *     同时提供一些解决方案，而且这个过程不需要我们手写测试用例。
     *     Lint 发现的每个问题都有描述信息和等级（和测试发现 bug 很相似），
     *     我们可以很方便地定位问题，同时按照严重程度进行解决。
     */


}

dependencies {
    implementation fileTree(dir: "libs", include: ["*.jar"])                  //本地jar包依赖
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.0.2'         //远程依赖
    //首页底部导航栏
    implementation 'com.flyco.tablayout:FlycoTabLayout_Lib:2.1.2@aar'
    //控件绑定
    implementation 'com.jakewharton:butterknife:10.0.0'
    implementation 'androidx.recyclerview:recyclerview:1.1.0'
    implementation 'androidx.navigation:navigation-fragment:2.3.1'
    implementation 'androidx.navigation:navigation-ui:2.3.1'
    implementation 'androidx.legacy:legacy-support-v4:1.0.0'
    implementation 'androidx.lifecycle:lifecycle-extensions:2.2.0'
    annotationProcessor 'com.jakewharton:butterknife-compiler:10.0.0'
    //列表
    implementation 'androidx.recyclerview:recyclerview-selection:1.1.0-rc03'
    //路由
    implementation 'com.alibaba:arouter-api:1.5.0'
    annotationProcessor "com.alibaba:arouter-compiler:1.2.2"

    //recyclerview的第三方adapter库
    implementation 'com.github.CymChad:BaseRecyclerViewAdapterHelper:3.0.4'

    //包括LogUtil的一些工具类
    implementation 'com.blankj:utilcode:1.13.5'

    //Retrofit
    implementation 'com.squareup.retrofit2:retrofit:2.6.2'
    implementation 'com.squareup.retrofit2:converter-gson:2.6.2'
    implementation 'com.squareup.retrofit2:adapter-rxjava2:2.6.2'
    implementation 'io.reactivex.rxjava2:rxandroid:2.1.1'

    //Room库
    implementation 'android.arch.persistence.room:runtime:1.0.0'
    annotationProcessor 'android.arch.persistence.room:compiler:1.0.0'

    //Glide图片下载器
    implementation 'com.github.bumptech.glide:glide:4.11.0'                        //本模块内使用
//    api 'com.github.bumptech.glide:glide:4.11.0'                                 //整个项目内使用


    testImplementation 'junit:junit:4.12'                                          //声明测试用例库
    androidTestImplementation 'androidx.test.ext:junit:1.1.2'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'


}


/**
 *   该闭包定义了项目的依赖关系，一般项目都有三种依赖方式：
 *   本地依赖、库依赖和远程依赖。本地依赖可以对本地的jar包或目录添加依赖关系，
 *   库依赖可以对项目中的库模块添加依赖关系，远程依赖可以对jcener库上的开源项目添加依赖关系。
 *   从Android Studio3.0后compile引入库不在使用，而是通过api和implementation，
 *   api完全等同于以前的compile，用api引入的库整个项目都可以使用，
 *   用implementation引入的库只有对应的Module能使用，
 *   其他Module不能使用，由于之前的项目统一用compile依赖，
 *   导致的情况就是模块耦合性太高，不利于项目拆解，
 *   使用implementation之后虽然使用起来复杂了但是做到降低偶合兴提高安全性。
 */